const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const config_mod = require('./config');
const config = config_mod.load_config({ required: false }) || null;

function parseArgs(argv) {
  const options = {
    auto: false,
    offset: null,
    base: null,
    alias: null,
    shared_db: false,
    dir: process.cwd(),
    force: false,
    docker: false,
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];

    if (arg === '--auto') {
      options.auto = true;
      continue;
    }

    if (arg === '--docker') {
      options.docker = true;
      continue;
    }

    if (arg === '--force') {
      options.force = true;
      continue;
    }

    if (arg === '--shared-db') {
      options.shared_db = true;
      continue;
    }

    if (arg === '--offset') {
      options.offset = argv[i + 1];
      i += 1;
      continue;
    }

    if (arg.startsWith('--offset=')) {
      options.offset = arg.split('=')[1];
      continue;
    }

    if (arg === '--base') {
      options.base = argv[i + 1];
      i += 1;
      continue;
    }

    if (arg.startsWith('--base=')) {
      options.base = arg.split('=')[1];
      continue;
    }

    if (arg === '--alias') {
      options.alias = argv[i + 1];
      i += 1;
      continue;
    }

    if (arg.startsWith('--alias=')) {
      options.alias = arg.split('=')[1];
      continue;
    }

    if (arg === '--dir') {
      options.dir = argv[i + 1];
      i += 1;
      continue;
    }

    if (arg.startsWith('--dir=')) {
      options.dir = arg.split('=')[1];
      continue;
    }

    console.error(`Unknown argument: ${arg}`);
    return null;
  }

  if (!options.auto && options.offset === null && options.base === null) {
    options.auto = true;
  }

  return options;
}

function parseInteger(value, label) {
  const parsed = Number.parseInt(value, 10);
  if (Number.isNaN(parsed)) {
    throw new Error(`${label} must be an integer`);
  }
  return parsed;
}

function computeAutoOffset(seed) {
  const hash = crypto.createHash('sha256').update(seed).digest('hex');
  const hashInt = Number.parseInt(hash.slice(0, 8), 16);
  return (hashInt % 2000) + 100;
}

function formatEnvLines(options) {
  const resolvedDir = path.resolve(options.dir);
  const worktreeName = path.basename(resolvedDir);

  const offsetValue =
    options.offset !== null
      ? parseInteger(options.offset, 'WORKTREE_PORT_OFFSET')
      : options.base === null
        ? computeAutoOffset(options.dir)
        : null;

  if (options.docker) {
    const db_name = config
      ? (options.shared_db ? (config.database.defaultDb || 'db') : (options.alias ? config_mod.db_name(config, options.alias) : (config.database.defaultDb || 'db')))
      : (options.shared_db ? 'db' : (options.alias ? `db_${options.alias.replace(/[^a-zA-Z0-9_]/g, '_')}` : 'db'));

    const VAR_PATH = config ? config_mod.env_var(config, 'projectPath') : 'PROJECT_PATH';
    const VAR_NAME = config ? config_mod.worktree_var(config, 'name') : 'WORKTREE_NAME';
    const VAR_ALIAS = config ? config_mod.worktree_var(config, 'alias') : 'WORKTREE_ALIAS';
    const VAR_MONGO = config ? config_mod.env_var(config, 'dbConnection') : 'MONGO_URL';
    const VAR_REPLICA = config ? config_mod.env_var(config, 'dbReplicaSet') : 'MONGO_REPLICA_SET';
    const VAR_REDIS_HOST = config ? config_mod.env_var(config, 'redisHost') : 'REDIS_HOST';
    const VAR_REDIS_PORT = config ? config_mod.env_var(config, 'redisPort') : 'REDIS_PORT';
    const VAR_LOCAL_IP = config ? config_mod.env_var(config, 'localIp') : 'LOCAL_IP';
    const VAR_APP_URL = config ? config_mod.env_var(config, 'appUrl') : 'APP_URL';
    const VAR_DEV_HEAP = config ? config_mod.worktree_var(config, 'devHeap') : 'WORKTREE_DEV_HEAP';

    const container_workdir = config ? config.docker.generate.containerWorkdir : '/app';
    const db_container_host = config ? config.database.containerHost : 'mongo';
    const db_port = config ? config.database.port : 27017;
    const replica_set = config ? config.database.replicaSet : 'rl0';
    const redis_host = config ? config.redis.containerHost : 'redis';
    const redis_port = config ? config.redis.port : 6379;
    const dev_heap = config ? config.features.devHeap : 2048;

    const lines = [
      '# Generated by scripts/worktree/create-worktree-env.js (docker)',
      `${VAR_PATH}=${container_workdir}`,
      `${VAR_NAME}=${worktreeName}`,
    ];
    if (options.alias) {
      lines.push(`${VAR_ALIAS}=${options.alias}`);
    }
    const domain = config
      ? (options.alias ? config_mod.domain_for(config, options.alias) : 'localhost')
      : (options.alias ? `${options.alias.replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase()}.localhost` : 'localhost');
    lines.push(
      `${VAR_MONGO}=mongodb://${db_container_host}:${db_port}/${db_name}`,
      `${VAR_REPLICA}=${replica_set}`,
      `${VAR_REDIS_HOST}=${redis_host}`,
      `${VAR_REDIS_PORT}=${redis_port}`,
      `${VAR_LOCAL_IP}=${domain}`,
      `${VAR_APP_URL}=http://${domain}/`,
      `${VAR_DEV_HEAP}=${dev_heap}`,
      '',
    );
    return lines;
  }

  const VAR_PATH = config ? config_mod.env_var(config, 'projectPath') : 'PROJECT_PATH';
  const VAR_NAME = config ? config_mod.worktree_var(config, 'name') : 'WORKTREE_NAME';

  if (options.base !== null) {
    const VAR_PORT_BASE = config ? config_mod.worktree_var(config, 'portBase') : 'WORKTREE_PORT_BASE';
    const base = parseInteger(options.base, VAR_PORT_BASE);
    return [
      '# Generated by scripts/worktree/create-worktree-env.js',
      `${VAR_PATH}=${resolvedDir}`,
      `${VAR_NAME}=${worktreeName}`,
      `${VAR_PORT_BASE}=${base}`,
      '',
    ];
  }

  const VAR_PORT_OFFSET = config ? config_mod.worktree_var(config, 'portOffset') : 'WORKTREE_PORT_OFFSET';
  return [
    '# Generated by scripts/worktree/create-worktree-env.js',
    `${VAR_PATH}=${resolvedDir}`,
    `${VAR_NAME}=${worktreeName}`,
    `${VAR_PORT_OFFSET}=${offsetValue}`,
    '',
  ];
}

function main() {
  const options = parseArgs(process.argv.slice(2));
  if (!options) {
    process.exit(1);
  }

  const targetDir = path.resolve(options.dir);
  if (!fs.existsSync(targetDir)) {
    console.error(`Directory does not exist: ${targetDir}`);
    process.exit(1);
  }

  if (!options.auto && options.offset === null && options.base === null) {
    console.error('Provide --auto, --offset, or --base.');
    process.exit(1);
  }

  const envFilename = config ? config.env.filename : '.env.worktree';
  const envPath = path.join(targetDir, envFilename);
  if (fs.existsSync(envPath) && !options.force) {
    console.error(`${envFilename} already exists at ${envPath}. Use --force to overwrite.`);
    process.exit(1);
  }

  const lines = formatEnvLines(options);
  fs.writeFileSync(envPath, `${lines.join('\n')}\n`, 'utf8');
  console.log(`Wrote ${envPath}`);
}

main();
