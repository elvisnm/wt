const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { SERVICE_PORTS, SERVICE_MODE_FILTERS } = require('./service-ports');
const config_mod = require('./config');
const config = config_mod.load_config({ required: false }) || null;

function sanitize_name(name) {
  return name.replace(/[^a-zA-Z0-9_-]/g, '-').toLowerCase();
}

function generate(worktree_path, worktree_name, port_offset, repo_root, service_mode, alias, host_build) {
  const safe_name = alias ? sanitize_name(alias) : sanitize_name(worktree_name);
  const service_name = config ? config_mod.container_name(config, safe_name) : safe_name;
  const domain = config ? config_mod.domain_for(config, safe_name) || `${safe_name}.localhost` : `${safe_name}.localhost`;
  const aws_dir = path.join(os.homedir(), '.aws');
  const docker_dir = path.join(repo_root, 'docker');

  const svc_ports = config ? config.services.ports : SERVICE_PORTS;
  const mode_filter = config
    ? config_mod.services_for_mode(config, service_mode)
    : SERVICE_MODE_FILTERS[service_mode];
  let port_entries = mode_filter
    ? Object.entries(svc_ports).filter(([name]) => mode_filter.includes(name))
    : Object.entries(svc_ports);
  // Exclude livereload when host_build is active (config-aware or legacy)
  const livereload_excluded = config ? config_mod.feature_enabled(config, 'hostBuild') && host_build : host_build;
  if (livereload_excluded) {
    port_entries = port_entries.filter(([name]) => name !== 'livereload');
  }

  const port_lines = port_entries
    .map(([name, base]) => {
      const host_port = base + port_offset;
      const container_port = name === 'livereload' ? host_port : base;
      return `      - "${host_port}:${container_port}"`;
    })
    .join('\n');

  // Config-based values with legacy fallbacks
  const image = config ? config.docker.baseImage : 'dev:latest';
  const container_workdir = config ? config.docker.generate.containerWorkdir : '/app';
  const vol_prefix = config ? config_mod.volume_prefix(config, safe_name) : safe_name;
  // Derive a short YAML key for the network from the full external name
  // e.g. 'infra_app_network' → 'app_network' (strip up to first '_')
  const network_alias = config
    ? (config.docker.sharedInfra.network.includes('_')
        ? config.docker.sharedInfra.network.replace(/^[^_]+_/, '')
        : config.docker.sharedInfra.network)
    : 'default';
  const network_name = config ? config.docker.sharedInfra.network : 'infra_default';
  const entrypoint_cmd = config ? config.docker.generate.entrypoint : 'pnpm dev';
  const env_filename = config ? config.env.filename : '.env.worktree';

  // Build extra mounts from config or legacy fakes3
  const extra_mount_lines = config && config.docker.generate.extraMounts.length > 0
    ? config.docker.generate.extraMounts.map(m => `      - ${m}`).join('\n')
    : `      - ${repo_root}/fakes3:${container_workdir}/fakes3`;

  // Build environment lines from config or legacy
  const base_env_lines = config && Object.keys(config.docker.generate.extraEnv).length > 0
    ? Object.entries(config.docker.generate.extraEnv).map(([k, v]) => `      - ${k}=${v}`).join('\n')
    : '';
  const env_prefix = config ? config.env.prefix : 'APP';
  const env_var_name = config ? config_mod.env_var(config, 'environment') || `${env_prefix}_ENV` : 'APP_ENV';
  const svc_var_name = config ? config_mod.worktree_var(config, 'services') || 'WORKTREE_SERVICES' : 'WORKTREE_SERVICES';

  // Build the entrypoint command array for the command directive
  const entrypoint_parts = entrypoint_cmd.split(/\s+/);
  const command_no_build = host_build
    ? JSON.stringify([...entrypoint_parts, '--no-build'])
    : JSON.stringify(entrypoint_parts);

  const yaml = `# Generated by scripts/worktree/generate-docker-compose.js
# Do not edit — regenerate with: pnpm worktree <name> --docker
services:
  ${service_name}:
    image: ${image}
    container_name: ${service_name}
    volumes:
      - .:${container_workdir}
${extra_mount_lines}
      - ./.docker-overrides/ecosystem.dev.config.js:${container_workdir}/ecosystem.dev.config.js:ro
      - ./.docker-overrides/scripts/dev.js:${container_workdir}/scripts/dev.js:ro
      - ./.docker-overrides/scripts/deployment_scripts/build.js:${container_workdir}/scripts/deployment_scripts/build.js:ro
      - ./.docker-overrides/frontend/js/lib/cache_socket.js:${container_workdir}/frontend/js/lib/cache_socket.js:ro
      - ${vol_prefix}_node_modules:${container_workdir}/node_modules
      - ${aws_dir}:/root/.aws:ro
    env_file:
      - ${env_filename}
    environment:
      - ${env_var_name}=development
      - NODE_ENV=development
      - ${svc_var_name}=${service_mode}${base_env_lines ? '\n' + base_env_lines : ''}
    entrypoint: ["docker-entrypoint.sh"]
    command: ${command_no_build}
    ports:
${port_lines}
    networks:
      - ${network_alias}
    extra_hosts:
      - "host.docker.internal:host-gateway"
    healthcheck:
      test: ["CMD-SHELL", "pm2 list 2>/dev/null | grep -q online"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 60s
    tty: true

volumes:
  ${vol_prefix}_node_modules:

networks:
  ${network_alias}:
    external: true
    name: ${network_name}
`;

  return yaml;
}

function parseArgs(argv) {
  const options = {
    worktree_path: null,
    worktree_name: null,
    alias: null,
    port_offset: null,
    service_mode: null,
    lan_domain: null,
    host_build: false,
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];

    if (arg === '--path') {
      options.worktree_path = argv[i + 1];
      i += 1;
      continue;
    }
    if (arg.startsWith('--path=')) {
      options.worktree_path = arg.split('=')[1];
      continue;
    }

    if (arg === '--name') {
      options.worktree_name = argv[i + 1];
      i += 1;
      continue;
    }
    if (arg.startsWith('--name=')) {
      options.worktree_name = arg.split('=')[1];
      continue;
    }

    if (arg === '--alias') {
      options.alias = argv[i + 1];
      i += 1;
      continue;
    }
    if (arg.startsWith('--alias=')) {
      options.alias = arg.split('=')[1];
      continue;
    }

    if (arg === '--offset') {
      options.port_offset = Number.parseInt(argv[i + 1], 10);
      i += 1;
      continue;
    }
    if (arg.startsWith('--offset=')) {
      options.port_offset = Number.parseInt(arg.split('=')[1], 10);
      continue;
    }

    if (arg === '--mode') {
      options.service_mode = argv[i + 1];
      i += 1;
      continue;
    }
    if (arg.startsWith('--mode=')) {
      options.service_mode = arg.split('=')[1];
      continue;
    }

    if (arg === '--host-build') {
      options.host_build = true;
      continue;
    }

    if (arg === '--lan-domain') {
      options.lan_domain = argv[i + 1];
      i += 1;
      continue;
    }
    if (arg.startsWith('--lan-domain=')) {
      options.lan_domain = arg.split('=')[1];
      continue;
    }

    console.error(`Unknown argument: ${arg}`);
    return null;
  }

  return options;
}

function main() {
  const { VALID_SERVICE_MODES, DEFAULT_SERVICE_MODE } = require('./service-ports');
  const options = parseArgs(process.argv.slice(2));
  if (!options || !options.worktree_path || !options.worktree_name || options.port_offset === null || Number.isNaN(options.port_offset)) {
    console.log(`Usage: node generate-docker-compose.js --path <worktree_path> --name <name> --offset <n> [--mode <${VALID_SERVICE_MODES.join('|')}>]`);
    process.exit(1);
  }

  if (!options.service_mode) {
    options.service_mode = DEFAULT_SERVICE_MODE;
  }

  if (!VALID_SERVICE_MODES.includes(options.service_mode)) {
    console.error(`Invalid service mode: ${options.service_mode}. Valid modes: ${VALID_SERVICE_MODES.join(', ')}`);
    process.exit(1);
  }

  const repo_root = execSync('git rev-parse --show-toplevel', { stdio: 'pipe', encoding: 'utf8' }).trim();
  const safe_name = options.alias ? sanitize_name(options.alias) : sanitize_name(options.worktree_name);
  const domain = config ? config_mod.domain_for(config, safe_name) || `${safe_name}.localhost` : `${safe_name}.localhost`;

  const yaml = generate(options.worktree_path, options.worktree_name, options.port_offset, repo_root, options.service_mode, options.alias, options.host_build);
  const out_path = path.join(options.worktree_path, 'docker-compose.worktree.yml');
  fs.writeFileSync(out_path, yaml, 'utf8');
  console.log(`Wrote ${out_path} (mode: ${options.service_mode})`);

  const traefik_dir = find_traefik_dir();
  if (traefik_dir) {
    const container = config ? config_mod.container_name(config, safe_name) : safe_name;
    const traefik_yaml = generate_traefik_config(safe_name, domain, container, options.port_offset, options.lan_domain);
    const traefik_path = path.join(traefik_dir, `${safe_name}.yml`);
    fs.writeFileSync(traefik_path, traefik_yaml, 'utf8');
    const domains = options.lan_domain ? `${domain}, ${options.lan_domain}` : domain;
    console.log(`Wrote ${traefik_path} (traefik: ${domains})`);
  }
}

function generate_traefik_config(safe_name, domain, service_name, port_offset, lan_domain) {
  const app_base = config ? (config.services.ports.app || 3001) : 3001;
  const socket_base = config ? (config.services.ports.socket_server || 3000) : 3000;
  const app_port = app_base + port_offset;
  const socket_port = socket_base + port_offset;

  const app_host = lan_domain
    ? `Host(\`${domain}\`) || Host(\`${lan_domain}\`)`
    : `Host(\`${domain}\`)`;
  const socket_host = lan_domain
    ? `(Host(\`${domain}\`) || Host(\`${lan_domain}\`)) && PathPrefix(\`/socket.io\`)`
    : `Host(\`${domain}\`) && PathPrefix(\`/socket.io\`)`;

  return `# Generated by scripts/worktree/generate-docker-compose.js
# Traefik dynamic config for worktree: ${safe_name}
http:
  routers:
    ${safe_name}-app:
      rule: "${app_host}"
      entryPoints:
        - web
      service: ${safe_name}-app
    ${safe_name}-socket:
      rule: "${socket_host}"
      entryPoints:
        - web
      service: ${safe_name}-socket
      priority: 100
  services:
    ${safe_name}-app:
      loadBalancer:
        servers:
          - url: "http://host.docker.internal:${app_port}"
    ${safe_name}-socket:
      loadBalancer:
        servers:
          - url: "http://host.docker.internal:${socket_port}"
`;
}

function find_traefik_dir() {
  // Config-based: use resolved dynamic dir from proxy config
  if (config && config.docker.proxy && config.docker.proxy._dynamicDirResolved) {
    const dir = config.docker.proxy._dynamicDirResolved;
    if (fs.existsSync(dir)) return dir;
  }
  // No config — cannot determine traefik dir
  return null;
}

module.exports = { generate, generate_traefik_config, find_traefik_dir, sanitize_name };

if (require.main === module) {
  main();
}
